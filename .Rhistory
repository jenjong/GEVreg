n = 100
true_theta=c(100,30,0.1)
true_beta = 20*sin(seq(0, 2*pi, length = n))
# compute the 11 by 8 matrix of basis function values
x <- 1:n
norder <- 5
breaks <- seq(0,100,20)
Z <- bsplineS(x, breaks, norder)
p = ncol(Z)
basisobj = create.bspline.basis(rangeval=c(1, n), nbasis=NULL,
norder=norder, breaks= breaks, dropind=NULL,
quadvals=NULL, values=NULL)
Om = eval.penalty(basisobj, Lfdobj=int2Lfd(2), rng=c(1, n))
s = 1
sim.iter = 100
lambda_vec = seq(0, 1, length  = 50)
#for ( s in c(1:sim.iter) ) {
set.seed(s)
eps = rgev(n,loc=true_theta[1], scale=true_theta[2], shape=true_theta[3])
Y = true_beta + eps
##### theta, beta MLE
eps1 = rgev(n,loc=true_theta[1], scale=true_theta[2], shape=true_theta[3])
tY = true_beta + eps1
v = rep(0,length(lambda_vec))
for (j in 1:length(lambda_vec))
{
lambda = lambda_vec[j]
fit <- try(GEV_regfull(x=Y, z=Z, theta0=true_theta,
beta0=rep(0,p), expr=expr_reg,
method = 'B-spline',
Om = Om, lambda = lambda,
alpha=0.5, maxiter=100)$root, silent = T)
m = fit[1] + Z%*%fit[-(1:3)]
a = fit[2]
k = fit[3]
v[j] =  sum(dgev(tY,m,a,k, log = T))
}
j
lambda
GEV_regfull(x=Y, z=Z, theta0=true_theta,
beta0=rep(0,p), expr=expr_reg,
method = 'B-spline',
Om = Om, lambda = lambda,
alpha=0.5, maxiter=100)
for (j in 1:length(lambda_vec))
{
lambda = lambda_vec[j]
fit <- GEV_regfull(x=Y, z=Z, theta0=true_theta,
beta0=rep(0,p), expr=expr_reg,
method = 'B-spline',
Om = Om, lambda = lambda,
alpha=0.5, maxiter=100)
}
# Finding MLE for nonstationary - fullhessian method
x=Y; z=Z; theta0=c(100,30,0.1);beta0=rep(0,ncol(Z)); expr=expr_reg; alpha=0.5; maxiter=100
method = 'B-spline' ; lambda = 1
n = length(x)
old_theta <- c(theta0,beta0)
#if (method == 'B-spline' ) old_theta[1] = 0
new_theta <- old_theta
niter <- 0
Jaco <- expr$Jaco
Hmat <- expr$Hmat
for (i in 1:100)
{
# if the spline is used, the intercept is not updated for identifiability
niter = niter + 1
mu = c(old_theta[1]+z%*%old_theta[-(1:3)])
s  = old_theta[2]
k  = old_theta[3]
grad = apply(cbind(eval(Jaco),eval(Jaco)[,1]*z),2,mean, na.rm = T)
if (method == 'B-spline' )
{
grad[-(1:3)] = grad[-(1:3)] + lambda*Om%*%old_theta[-(1:3)]*n
grad = grad[-1]
}
if (max(abs(grad))<1e-07){
break
}
hess = GEVhessian(x,z,mu,s,k)
hess = hess + diag(1e-8, ncol(hess))
if (method == 'B-spline' )
{
hess[-(1:3),-(1:3)] = hess[-(1:3),-(1:3)] + lambda*Om*n
hess = hess[-1,-1]
gd = -solve(hess)%*%grad
new_theta[-1] = old_theta[-1] + alpha*gd
if (new_theta[3]>0)
{
# check alpha
if (new_theta[2] < 0 )  stop ("alpha is unstable")
# check mu and kappa
mu.i = new_theta[1] +Z%*%new_theta[-(1:3)]
lx = (min(x) <= mu.i - new_theta[2]/new_theta[3])
if (any(lx))  stop ("mu and kappa is unstable")
}
if (new_theta[3]<0)
{
# check alpha
if (new_theta[2] < 0 )  stop ("alpha is unstable")
# check mu and kappa
mu.i = new_theta[1] +Z%*%new_theta[-(1:3)]
lx = (max(x) >= mu.i - new_theta[2]/new_theta[3])
if (any(lx))  stop ("mu and kappa is unstable")
}
}
if (method == 'linear' )
{
new_theta = old_theta - alpha*solve(hess)%*%grad
}
old_theta = new_theta
}
# Finding MLE for nonstationary - fullhessian method
x=Y; z=Z; theta0=c(100,30,0.1);beta0=rep(0,ncol(Z)); expr=expr_reg; alpha=0.5; maxiter=1000
method = 'B-spline' ; lambda = 1
n = length(x)
old_theta <- c(theta0,beta0)
#if (method == 'B-spline' ) old_theta[1] = 0
new_theta <- old_theta
niter <- 0
Jaco <- expr$Jaco
Hmat <- expr$Hmat
for (i in 1:100)
{
# if the spline is used, the intercept is not updated for identifiability
niter = niter + 1
mu = c(old_theta[1]+z%*%old_theta[-(1:3)])
s  = old_theta[2]
k  = old_theta[3]
grad = apply(cbind(eval(Jaco),eval(Jaco)[,1]*z),2,mean, na.rm = T)
if (method == 'B-spline' )
{
grad[-(1:3)] = grad[-(1:3)] + lambda*Om%*%old_theta[-(1:3)]*n
grad = grad[-1]
}
if (max(abs(grad))<1e-07){
break
}
hess = GEVhessian(x,z,mu,s,k)
hess = hess + diag(1e-8, ncol(hess))
if (method == 'B-spline' )
{
hess[-(1:3),-(1:3)] = hess[-(1:3),-(1:3)] + lambda*Om*n
hess = hess[-1,-1]
gd = -solve(hess)%*%grad
new_theta[-1] = old_theta[-1] + alpha*gd
if (new_theta[3]>0)
{
# check alpha
if (new_theta[2] < 0 )  stop ("alpha is unstable")
# check mu and kappa
mu.i = new_theta[1] +Z%*%new_theta[-(1:3)]
lx = (min(x) <= mu.i - new_theta[2]/new_theta[3])
if (any(lx))  stop ("mu and kappa is unstable")
}
if (new_theta[3]<0)
{
# check alpha
if (new_theta[2] < 0 )  stop ("alpha is unstable")
# check mu and kappa
mu.i = new_theta[1] +Z%*%new_theta[-(1:3)]
lx = (max(x) >= mu.i - new_theta[2]/new_theta[3])
if (any(lx))  stop ("mu and kappa is unstable")
}
}
if (method == 'linear' )
{
new_theta = old_theta - alpha*solve(hess)%*%grad
}
old_theta = new_theta
}
new_theta
true_theta
p
ncol(Z)
Om
lambda
fit <- GEV_regfull(x=Y, z=Z, theta0=true_theta,
beta0=rep(0,p), expr=expr_reg,
method = 'B-spline',
Om = Om, lambda = lambda,
alpha=0.5, maxiter=1000)
rm( list = ls()); gc()
if (Sys.info()[1] == "Linux") {
setwd("/home/jeon/Documents/GitHub/GEVreg")
} else {
setwd('C:/Users/Jeon/Documents/GitHub/GEVreg')
}
library("fda")
library("Deriv")
library("evd")
library("quantreg")
source("./test/fgevlibrary.R")
source("./test/testlibrary.R")
n = 100
true_theta=c(100,30,0.1)
true_beta = 20*sin(seq(0, 2*pi, length = n))
# compute the 11 by 8 matrix of basis function values
x <- 1:n
norder <- 5
breaks <- seq(0,100,20)
Z <- bsplineS(x, breaks, norder)
p = ncol(Z)
basisobj = create.bspline.basis(rangeval=c(1, n), nbasis=NULL,
norder=norder, breaks= breaks, dropind=NULL,
quadvals=NULL, values=NULL)
Om = eval.penalty(basisobj, Lfdobj=int2Lfd(2), rng=c(1, n))
s = 1
sim.iter = 100
lambda_vec = seq(0, 1, length  = 50)
#for ( s in c(1:sim.iter) ) {
set.seed(s)
eps = rgev(n,loc=true_theta[1], scale=true_theta[2], shape=true_theta[3])
Y = true_beta + eps
##### theta, beta MLE
eps1 = rgev(n,loc=true_theta[1], scale=true_theta[2], shape=true_theta[3])
tY = true_beta + eps1
v = rep(0,length(lambda_vec))
for (j in 1:length(lambda_vec))
{
lambda = lambda_vec[j]
fit <- GEV_regfull(x=Y, z=Z, theta0=true_theta,
beta0=rep(0,p), expr=expr_reg,
method = 'B-spline',
Om = Om, lambda = lambda,
alpha=0.5, maxiter=1000)
}
i
j
lambda
fit <- GEV_regfull(x=Y, z=Z, theta0=true_theta,
beta0=rep(0,p), expr=expr_reg,
method = 'B-spline',
Om = Om, lambda = lambda,
alpha=0.5, maxiter=1000)
fit <- GEV_regfull(x=Y, z=Z, theta0=true_theta,
beta0=rep(0,p), expr=expr_reg,
method = 'B-spline',
Om = Om, lambda = lambda,
alpha=0.5, maxiter=1000)
true_theta
expr_reg
GEV_regfull(x=Y, z=Z, theta0=true_theta,
beta0=rep(0,p), expr=expr_reg,
method = 'B-spline',
Om = Om, lambda = lambda,
alpha=0.5, maxiter=1000)
Y
Z
fit <- GEV_regfull(x=Y, z=Z, theta0=true_theta,
beta0=rep(0,p), expr=expr_reg,
method = 'B-spline',
Om = Om, lambda = lambda,
alpha=1, maxiter=1000)
# Finding MLE for nonstationary - fullhessian method
x=Y; z=Z; theta0=c(100,30,0.1);beta0=rep(0,ncol(Z)); expr=expr_reg; alpha=1; maxiter=1000
method = 'B-spline' ; lambda = 1
n = length(x)
old_theta <- c(theta0,beta0)
#if (method == 'B-spline' ) old_theta[1] = 0
new_theta <- old_theta
niter <- 0
Jaco <- expr$Jaco
Hmat <- expr$Hmat
for (i in 1:100)
{
# if the spline is used, the intercept is not updated for identifiability
niter = niter + 1
mu = c(old_theta[1]+z%*%old_theta[-(1:3)])
s  = old_theta[2]
k  = old_theta[3]
grad = apply(cbind(eval(Jaco),eval(Jaco)[,1]*z),2,mean, na.rm = T)
if (method == 'B-spline' )
{
grad[-(1:3)] = grad[-(1:3)] + lambda*Om%*%old_theta[-(1:3)]*n
grad = grad[-1]
}
if (max(abs(grad))<1e-07){
break
}
hess = GEVhessian(x,z,mu,s,k)
hess = hess + diag(1e-8, ncol(hess))
if (method == 'B-spline' )
{
hess[-(1:3),-(1:3)] = hess[-(1:3),-(1:3)] + lambda*Om*n
hess = hess[-1,-1]
gd = -solve(hess)%*%grad
new_theta[-1] = old_theta[-1] + alpha*gd
if (new_theta[3]>0)
{
# check alpha
if (new_theta[2] < 0 )  stop ("alpha is unstable")
# check mu and kappa
mu.i = new_theta[1] +Z%*%new_theta[-(1:3)]
lx = (min(x) <= mu.i - new_theta[2]/new_theta[3])
if (any(lx))  stop ("mu and kappa is unstable")
}
if (new_theta[3]<0)
{
# check alpha
if (new_theta[2] < 0 )  stop ("alpha is unstable")
# check mu and kappa
mu.i = new_theta[1] +Z%*%new_theta[-(1:3)]
lx = (max(x) >= mu.i - new_theta[2]/new_theta[3])
if (any(lx))  stop ("mu and kappa is unstable")
}
}
if (method == 'linear' )
{
new_theta = old_theta - alpha*solve(hess)%*%grad
}
old_theta = new_theta
}
new_theta
# Finding MLE for nonstationary - fullhessian method
x=Y; z=Z; theta0=c(100,30,0.1);beta0=rep(0,ncol(Z)); expr=expr_reg; alpha=1; maxiter=1000
method = 'B-spline' ; lambda = 1
n = length(x)
old_theta <- c(theta0,beta0)
#if (method == 'B-spline' ) old_theta[1] = 0
new_theta <- old_theta
niter <- 0
Jaco <- expr$Jaco
Hmat <- expr$Hmat
for (i in 1:maxiter)
{
# if the spline is used, the intercept is not updated for identifiability
niter = niter + 1
mu = c(old_theta[1]+z%*%old_theta[-(1:3)])
s  = old_theta[2]
k  = old_theta[3]
grad = apply(cbind(eval(Jaco),eval(Jaco)[,1]*z),2,mean)
if (method == 'B-spline' )
{
grad[-(1:3)] = grad[-(1:3)] + lambda*Om%*%old_theta[-(1:3)]*n
grad = grad[-1]
}
if (max(abs(grad))<1e-07){
break
}
hess = GEVhessian(x,z,mu,s,k)
hess = hess + diag(1e-8, ncol(hess))
if (method == 'B-spline' )
{
hess[-(1:3),-(1:3)] = hess[-(1:3),-(1:3)] + lambda*Om*n
hess = hess[-1,-1]
gd = -solve(hess)%*%grad
new_theta[-1] = old_theta[-1] + alpha*gd
if (new_theta[3]>0)
{
# check alpha
if (new_theta[2] < 0 )  stop ("alpha is unstable")
# check mu and kappa
mu.i = new_theta[1] +Z%*%new_theta[-(1:3)]
lx = (min(x) <= mu.i - new_theta[2]/new_theta[3])
if (any(lx))  stop ("mu and kappa is unstable")
}
if (new_theta[3]<0)
{
# check alpha
if (new_theta[2] < 0 )  stop ("alpha is unstable")
# check mu and kappa
mu.i = new_theta[1] +Z%*%new_theta[-(1:3)]
lx = (max(x) >= mu.i - new_theta[2]/new_theta[3])
if (any(lx))  stop ("mu and kappa is unstable")
}
}
if (method == 'linear' )
{
new_theta = old_theta - alpha*solve(hess)%*%grad
}
old_theta = new_theta
}
new_theta
lambda_vec
rm( list = ls()); gc()
if (Sys.info()[1] == "Linux") {
setwd("/home/jeon/Documents/GitHub/GEVreg")
} else {
setwd('C:/Users/Jeon/Documents/GitHub/GEVreg')
}
library("fda")
library("Deriv")
library("evd")
library("quantreg")
source("./test/fgevlibrary.R")
source("./test/testlibrary.R")
n = 100
true_theta=c(100,30,0.1)
true_beta = 20*sin(seq(0, 2*pi, length = n))
# compute the 11 by 8 matrix of basis function values
x <- 1:n
norder <- 5
breaks <- seq(0,100,20)
Z <- bsplineS(x, breaks, norder)
p = ncol(Z)
basisobj = create.bspline.basis(rangeval=c(1, n), nbasis=NULL,
norder=norder, breaks= breaks, dropind=NULL,
quadvals=NULL, values=NULL)
Om = eval.penalty(basisobj, Lfdobj=int2Lfd(2), rng=c(1, n))
s = 1
sim.iter = 100
lambda_vec = seq(0, 1, length  = 50)
#for ( s in c(1:sim.iter) ) {
set.seed(s)
eps = rgev(n,loc=true_theta[1], scale=true_theta[2], shape=true_theta[3])
Y = true_beta + eps
##### theta, beta MLE
eps1 = rgev(n,loc=true_theta[1], scale=true_theta[2], shape=true_theta[3])
tY = true_beta + eps1
v = rep(0,length(lambda_vec))
lambda
for (j in 1:length(lambda_vec))
{
lambda = lambda_vec[j]
fit <- GEV_regfull(x=Y, z=Z, theta0=true_theta,
beta0=rep(0,p), expr=expr_reg,
method = 'B-spline',
Om = Om, lambda = lambda,
alpha=1, maxiter=1000)
}
lambda
x=Y; z=Z; theta0=c(100,30,0.1);beta0=rep(0,ncol(Z)); expr=expr_reg; alpha=1; maxiter=1000
method = 'B-spline' ; lambda = 0
n = length(x)
old_theta <- c(theta0,beta0)
#if (method == 'B-spline' ) old_theta[1] = 0
new_theta <- old_theta
niter <- 0
Jaco <- expr$Jaco
Hmat <- expr$Hmat
for (i in 1:maxiter)
{
# if the spline is used, the intercept is not updated for identifiability
niter = niter + 1
mu = c(old_theta[1]+z%*%old_theta[-(1:3)])
s  = old_theta[2]
k  = old_theta[3]
grad = apply(cbind(eval(Jaco),eval(Jaco)[,1]*z),2,mean)
if (method == 'B-spline' )
{
grad[-(1:3)] = grad[-(1:3)] + lambda*Om%*%old_theta[-(1:3)]*n
grad = grad[-1]
}
if (max(abs(grad))<1e-07){
break
}
hess = GEVhessian(x,z,mu,s,k)
hess = hess + diag(1e-8, ncol(hess))
if (method == 'B-spline' )
{
hess[-(1:3),-(1:3)] = hess[-(1:3),-(1:3)] + lambda*Om*n
hess = hess[-1,-1]
gd = -solve(hess)%*%grad
new_theta[-1] = old_theta[-1] + alpha*gd
if (new_theta[3]>0)
{
# check alpha
if (new_theta[2] < 0 )  stop ("alpha is unstable")
# check mu and kappa
mu.i = new_theta[1] +Z%*%new_theta[-(1:3)]
lx = (min(x) <= mu.i - new_theta[2]/new_theta[3])
if (any(lx))  stop ("mu and kappa is unstable")
}
if (new_theta[3]<0)
{
# check alpha
if (new_theta[2] < 0 )  stop ("alpha is unstable")
# check mu and kappa
mu.i = new_theta[1] +Z%*%new_theta[-(1:3)]
lx = (max(x) >= mu.i - new_theta[2]/new_theta[3])
if (any(lx))  stop ("mu and kappa is unstable")
}
}
if (method == 'linear' )
{
new_theta = old_theta - alpha*solve(hess)%*%grad
}
old_theta = new_theta
}
i
hess
alpha
new_theta
hess
gd
old_theta
new_theta[2]
old_theta[2]
old_theta[2] -new_theta[2]
old_theta[2]
new_theta[2]
old_theta[2] - new_theta[2]
old_theta[2] - new_theta[2]
alpha
gd
gd[2]
old_theta[2] - gd[1]
gd[1]
old_theta[2] + gd[1]
1 - old_theta[2]
(1 - old_theta[2] )/gd[1]
(1 - old_theta[2] )/gd[1]
min.h = (1 - old_theta[2] )/gd[1]
old_theta[-1] + min.h*gd
min.h = 1
min.h
(1 - old_theta[2] )/gd[1]
2^((-20):0)
hvec = 2^((-20):0)
new_theta[1]
new_theta[1]
